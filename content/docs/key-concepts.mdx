---
title: Key Concepts
icon: Key
---

The **Agent2Agent (A2A) protocol** is built around a set of core concepts that define how agents interact. Understanding these concepts is crucial for developing or integrating with A2A-compliant systems.



## Core Actors

### User
The end user (human or automated service) who initiates a request or goal that requires agent assistance.

### A2A Client (Client Agent)
An application, service, or another AI agent that acts on behalf of the user to request actions or information from a remote agent. The client initiates communication using the A2A protocol.

### A2A Server (Remote Agent)
An AI agent or agentic system that exposes an HTTP endpoint implementing the A2A protocol. It receives requests from clients, processes tasks, and returns results or status updates. The remote agent operates as an **"opaque"** system from the client's perspective, meaning the client doesn't need to know its internal workings, memory, or tools.

## Fundamental Communication Elements

### Agent Card
A JSON metadata document, typically discoverable at a well-known URL (e.g., `/.well-known/agent.json`), that describes an A2A Server.

**Key Features:**
- Details the agent's identity (name, description)
- Service endpoint URL and version information
- Supported A2A capabilities (like streaming or push notifications)
- Specific skills it offers
- Default input/output modalities
- Authentication requirements

Clients use the Agent Card to discover agents and understand how to interact with them securely and effectively.

> 📖 See details in the [Protocol Specification: Agent Card](./specification.mdx#5-agent-discovery-the-agent-card)

### Task
When a client sends a message to an agent, the agent might determine that fulfilling the request requires a stateful task to be completed (e.g., "generate a report," "book a flight," "answer a question").

**Task Characteristics:**
- Each task has a unique ID defined by the agent
- Progresses through a defined lifecycle (submitted, working, input-required, completed, failed)
- Tasks are stateful and can involve multiple exchanges (messages) between client and server

> 📖 See details in the [Protocol Specification: Task Object](./specification.mdx#61-task-object)

### Message
Represents a single turn or unit of communication between a client and an agent.

**Message Properties:**
- Messages have a **role** (either "user" for client-sent messages or "agent" for server-sent messages)
- Contain one or more **Part objects** that carry the actual content
- **messageId** is a unique identifier for each message set by the sender
- Used for conveying instructions, context, questions, answers, or status updates

> 📖 See details in the [Protocol Specification: Message Object](./specification.mdx#64-message-object)

### Part
The fundamental unit of content within a Message or an Artifact. Each part has a specific type and can carry different kinds of data:

#### TextPart
Contains plain textual content.

#### FilePart
Represents a file, which can be transmitted as inline base64-encoded bytes or referenced via a URI. Includes metadata like filename and Media Type.

#### DataPart
Carries structured JSON data, useful for forms, parameters, or any machine-readable information.

> 📖 See details in the [Protocol Specification: Part Union Type](./specification.mdx#65-part-union-type)

### Artifact
Represents a tangible output or result generated by the remote agent during the processing of a task.

**Examples include:**
- Generated documents
- Images
- Spreadsheets  
- Structured data results
- Any other self-contained piece of information that is a direct result of the task

Artifacts are composed of one or more Part objects and can be streamed incrementally.

> 📖 See details in the [Protocol Specification: Artifact Object](./specification.mdx#67-artifact-object)

## Interaction Mechanisms

### Request/Response (Polling)
The client sends a request (e.g., using the `message/send` RPC method) and receives a response from the server.

**Workflow:**
1. If the interaction requires a stateful long-running task, the server might initially respond with a working status
2. The client would then periodically call `tasks/get` to poll for updates
3. Polling continues until the task reaches a terminal state (completed, failed)

### Streaming (Server-Sent Events - SSE)
For tasks that produce results incrementally or provide real-time progress updates.

**How it Works:**
1. The client initiates an interaction with the server using `message/stream`
2. The server responds with an HTTP connection that remains open
3. Server sends a stream of Server-Sent Events (SSE) over this connection
4. Events can be Task, Message, TaskStatusUpdateEvent (for status changes) or TaskArtifactUpdateEvent (for new or updated artifact chunks)

> ⚠️ **Requirement:** The server must advertise the streaming capability in its Agent Card

> 📖 Learn more about [Streaming & Asynchronous Operations](./streaming-async-operations.mdx)

### Push Notifications
For very long-running tasks or scenarios where maintaining a persistent connection (like SSE) is impractical.

**Implementation:**
1. The client can provide a webhook URL when initiating a task (or by calling `tasks/pushNotificationConfig/set`)
2. When the task status changes significantly (completes, fails, or requires input), the server sends an asynchronous notification
3. Notification is sent as an HTTP POST request to the client-provided webhook

> ⚠️ **Requirement:** The server must advertise the pushNotifications capability in its Agent Card

> 📖 Learn more about [Streaming & Asynchronous Operations](./streaming-async-operations.mdx)

## Other Important Concepts

### Context (contextId)
A server-generated identifier that can be used to logically group multiple related Task objects, providing context across a series of interactions.

### Transport and Format
A2A communication occurs over **HTTP(S)**. **JSON-RPC 2.0** is used as the payload format for all requests and responses.

### Authentication & Authorization
A2A relies on standard web security practices:
- Authentication requirements are declared in the Agent Card
- Credentials (OAuth tokens, API keys) are typically passed via HTTP headers
- Credentials are separate from the A2A protocol messages themselves

> 📖 Learn more about [Enterprise-Ready Features](./enterprise-ready-features.mdx)

### Agent Discovery
The process by which clients find Agent Cards to learn about available A2A Servers and their capabilities.

> 📖 Learn more about [Agent Discovery](./agent-discovery.mdx)

### Extensions
A2A allows agents to declare custom protocol extensions as part of their AgentCard.

> 🚧 More documentation coming soon.

---

By understanding these core components and mechanisms, developers can effectively design, implement, and utilize A2A for building interoperable and collaborative AI agent systems.
